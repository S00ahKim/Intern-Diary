# 2020년 5월 26일

### GNU nano 에디터
- vi랑 다르게 i 입력 안 하고 그냥 입력해도 됨. 그래서 편하다고 하는 건가?
- 엔터 치고 컨트롤 O 누르고 엔터 치고(파일명 저장) 컨트롤 X해서 나가면 됨. wq에 너무 익숙해져 있어서 버벅거렸다.
- 약간 불편해서 다시 vi 에디터로 갈아타려고 검색했는데 그러려면 배쉬셀을 바꾸면 된다고 하는데, 그냥 이것도 한 번 적응해 보기로 했다.

### IAP 영수증 검증할 때 데이터 안 오는 경우
- 테스트 환경에서 21007번으로 상태 코드가 오는 경우에는 "이 영수증은 샌드 박스 영수증이지만 확인을 위해 생산 서비스로 전송되었습니다."라는 뜻이다. 
- [출처](https://blog.miyu.pe.kr/298)

### Postgre에서 돌아가고 있는 쿼리 확인
```
select * from pg_stat_activity order by query_start asc;
```
- CPU 점유율이 80프로에 달하는 기현상이 발생해서 날려본 쿼리. 이걸로는 사실 DB hit을 어떤 쿼리가 하고 있는지 확인하기 어렵긴 했음 (장고 내부에서 해서 그런 것으로 예상) 하지만 나중에 쓸 일이 있을지도 몰라서 써둠
- [실행중인 쿼리 확인 및 실행취소 방법](https://blog.gaerae.com/2015/09/postgresql-pg-stat-activity.html)

### Postgre에서 데이트타임 필드를 데이트로 조회
```
select created_at::date, count(*) as cnt from user_user where is_delete = false and is_admin = false group by created_at::date order by created_at::date desc;
```
- 시간까지 함께 기록하는 필드에서 날짜만 보고 싶을 때에는 뒤에 ::date를 붙이면 된다. 

### 스크립트 효율적으로 바꾸기
- 쿼리셋은 lazy하다. 즉, 선언과 fetch의 시간대가 다르다. 이걸 염두에 두고 코딩을 해야 비효율적인 콜이 발생하지 않는다. 내가 돌리던 스크립트에서 이 부분을 간과했더니 너무 비효율적으로 돌고 있어서 찾아봤다가 이런 문구를 발견했다. 반성하게 됐다...
> 몇 천 개 단위의 레코드를 다뤄야 할 경우, 이 데이터를 한 번에 가져와 메모리에 올리는 행위는 매우 비효율적이다. 더 나쁜 점은, 거대한 쿼리가 서버의 프로세스를 잠궈(lock) 버려서 웹 애플리케이션이 죽을 수도 있다는 사실이다. 

바꾼 방법은 아래와 같다. 아직 완전히 효율적으로 변화시킨 것은 아닐지라도 60%의 CPU 사용량을 20%까지 줄일 수 있었다.
1. iterator() 사용. 전체 데이터를 메모리에서 들고 있지 않고 쪼개서 가져와서 보고, 사용하면 지운다. 메모리 사용량을 조절할 수 있다. 
2. exists()의 사용. 단순히 존재하는지 여부를 물어볼 때에는 이 메소드 사용이 효율적이다.
3. values()에서 가져오는 값을 한정지었다. 필드가 많은 테이블을 조회할 때 혹시 도움이 될까봐. 

이렇게 고치고 나서 레오한테 칭찬을 받아서 기분이 좋았다. 코드도 요새 리팩토링 중인데, 아직 성능상 이슈가 발생하는 기능은 거의 없지만 사용자가 늘었을 때를 대비할 수 있겠지.